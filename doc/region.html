<HTML>
 <HEAD><TITLE>region.html</TITLE></HEAD>
 <BODY BGCOLOR="#FFFFFF">
  <HR>
   <H2>Regions</H2>
  <HR>
  <P>
  All Fract-O-Rama formula files have a section that looks like this:
  <PRE>
  formula
  {
     zero or more statements

     while(some_condition)
     {
        zero or more statements
     }

     zero or more statements
  }
  </PRE>
  <P>
  The 'while(some_condition)' part specifies the conditions under which
  the program will continue to execute the statements inside the while loop.
  <P>
  Here is a complete formula file with a typical while loop condition:
  <PRE>
  fractal
  {
     mapping { (-2, -2, 2, 2) => (200, 200) }

     formula
     {
        z = [0, 0];

        while($count &lt; 20 && ssq(z) &lt; 4)
        {
           z = z ^ 2 + current;
        }

        $value = deg(z) * (255 / 360.0);

        set_color($value, $value, $value);
     }
  }
  </PRE>
  <P>
  Many interesting fractals can be generated by varying the condition
  that governs the while loop.  Regions are one such mechanism, they
  provide a way to test to see if a point is within a certain area.
  Typically this is used in a manner like this:
  <PRE>
  fractal
  {
     mapping { (-2, -2, 2, 2) => (200, 200) }

     formula
     {
        z = [0, 0];

        while($count &lt; 20 && ssq(z) &lt; 4)
        {
           if(inside(z, /* some region */))
           {
              // our 'z' point is inside the region, leave the
              // while loop prematurely

              break;
           }
           z = z ^ 2 + current;
        }

        $value = deg(z) * (255 / 360.0);

        set_color($value, $value, $value);
     }
  }
  </PRE>
  Above <B>/* some region */</B> is a placeholder for an actual region but
  we can see how we go about testing to see if a point is within a region
  and now we'll look at the different types of regions that are available.
  <P>
  There are 6 types of regions and 4 ways to combine regions.  First, we'll
  look at the region types.
  <P>
  <TABLE BORDER=1>
   <TR>
    <TH>Region</TH>
    <TH>Explanation</TH>
   </TR>
   <TR>
    <TD><pre>r_circle(center, $radius)</pre></TD>
    <TD>This region describes a circle centered at 'center' with
        radius '$radius'</TD>
   </TR>
   <TR>
    <TD><pre>r_cross(p1, p2, $barWidth, $barHeight)</pre></TD>
    <TD>This region describes a rectangular area (p1 and p2 are the corners).
        The cross is incribed within the rectangular region and the
        thickness of the horizontal bar is '$barHeight' the thickness of
        the vertical bar is '$barWidth'</TD>
   </TR>
   <TR>
    <TD><pre>r_ellipse(center, $xradius, $yradius)</pre></TD>
    <TD>This region describes an ellipse whose center is 'center'.  The
        width of the ellipse is governed by '$xradius' its height
        by '$yradius'</TD>
   </TR>
   <TR>
    <TD><pre>r_poly(p1, p2, ..., pN)</pre></TD>
    <TD>This region is a polygon defined by the points p1, p2, ..., pN.
        There must be at least 3 points but there is limit on the maximum
        number of points</TD>
   </TR>
   <TR>
    <TD><pre>r_spoly(center, $nSides, $radius, $angle)</pre></TD>
    <TD>This region describes an '$nSides'-sided polygon whose center
        is 'center'.  The value '$radius' indicates the distance from
        the center to any of the polygon's '$nSides' points.  The
        '$angle' value rotates the polygon around its center, if this
        value is zero one point of the polygon will be at 0 degrees
        (3 o'clock).</TD>
   </TR>
   <TR>
    <TD><pre>r_rect(p1, p2)</TD>
    <TD>This region describes a rectangle whose opposite corners are
        the points 'p1' and 'p2'</TD>
   </TR>
  </TABLE>
  <P>
  Now let's look at some images of what these regions actually look like.
  For this discussion we'll assume the following:
  <P>
  <UL>
   <LI>Our drawing area is a square located at (0, 0), (1, 1)
   <LI>All our regions will be specified relative to our drawing
       area's coordinates
  </UL>
  <P>
  <TABLE BORDER=0 CELLSPACING=10>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="circle1.png"></TD></TR></TABLE>
        <BR><pre>r_circle([.5, 5.], .4)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="circle2.png"></TD></TR></TABLE>
        <BR><pre>r_circle([.4, 4.], .2)</pre></TD>
   </TR>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="cross1.png"></TD></TR></TABLE>
        <BR><pre>r_cross([.2, .2], [.8, .8], .2, .4)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="cross2.png"></TD></TR></TABLE>
        <BR><pre>r_cross([.1, .1], [.9, .9], .3, .1)</pre></TD>
   </TR>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="ellipse1.png"></TD></TR></TABLE>
        <BR><pre>r_ellipse([.5, .5], .4, .2)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="ellipse2.png"></TD></TR></TABLE>
        <BR><pre>r_ellipse([.5, .5], .2, .4)</pre></TD>
   </TR>

   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="poly1.png"></TD></TR></TABLE>
    <pre>
r_poly([.2, 0], [.3, .3], [.2, .3], [.3, .6],
       [.2, .6], [.4, 1],  [.3, .7],[.4, .7],
       [.3, .4],[.4, .4], [.2, 0])</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="poly2.png"></TD></TR></TABLE>
    <BR><pre>r_poly([.1, .1], [.2, .8], [.9, .3])</TD>
   </TR>

   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="spoly1.png"></TD></TR></TABLE>
    <BR><pre>r_spoly([.5, .5], 5, .4, 0)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="spoly2.png"></TD></TR></TABLE>
    <BR><pre>r_spoly([.5, .5], 6, .4, 20)</pre></TD>
   </TR>

   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="rect1.png"></TD></TR></TABLE>
    <BR><pre>r_rect([.1, .1], [.7, .8])</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="rect2.png"></TD></TR></TABLE>
    <BR><pre>r_rect([.3, .4], [.9, .1])</pre></TD>
   </TR>
  </TABLE>
  <P>
  Now lets look at the mechanisms for combining regions
  <P>
  <TABLE BORDER=1>
   <TR>
    <TD>r_and(region1, region2)</TD>
    <TD>Specifies the area that is in both region1 and region2</TD>
   </TR>
   <TR>
    <TD>r_or(region1, region2)</TD>
    <TD>Specifies the area that is in either region1 or region2</TD>
   </TR>
   <TR>
    <TD>r_xor(region1, region2)</TD>
    <TD>Specifies the area that is in either region1 or
        region2 but not both</TD>
   </TR>
   <TR>
    <TD>r_not(region)</TD>
    <TD>Specifies the area that is not in region</TD>
   </TR>
  </TABLE>
  <P>
  For these examples, we'll be using the following regions/images:
  <P>
  <TABLE BORDER=0>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="region1.png"></TD></TR></TABLE>
        <BR><pre>region1: r_circle([.3, 5.], .25)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="region2.png"></TD></TR></TABLE>
        <BR><pre>region2: r_circle([.6, 5.], .25)</pre></TD>
   </TR>
  </TABLE>
  <P>
  Here are images showing the different mechanisms for combining regions
  <P>
  <TABLE BORDER=0>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="and.png"></TD></TR></TABLE>
        <BR><pre>r_and(region1, region2)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="or.png"></TD></TR></TABLE>
        <BR><pre>r_or(region1, region2)</pre></TD>
   </TR>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="xor.png"></TD></TR></TABLE>
        <BR><pre>r_xor(region1, region2)</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="not.png"></TD></TR></TABLE>
        <BR><pre>r_not(region1)</pre></TD>
   </TR>
  </TABLE>
  <P>
  Finally, it is worth noting that the combining mechanisms (r_and, r_or,
  r_xor, r_not) are regions themselves so they can also be combined.
  Here are some examples:
  <P>
  <TABLE BORDER=0>
   <TR>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="not_xor.png"></TD></TR></TABLE>
        <BR><pre>r_not(r_xor(region1, region2))</pre></TD>
    <TD><TABLE BORDER=1><TR><TD><IMG SRC="not_or.png"></TD></TR></TABLE>
        <BR><pre>r_not(r_or(region1, region2))</pre></TD>
  </TABLE>
  <P>
  And here is a complete formula file that uses regions and the image
  it produces
  <PRE>
   fractal
   {
     mapping {
      (-2.00000000000000000000,
       -2.00000000000000000000,
       2.00000000000000000000,
       2.00000000000000000000) => (200, 200)
     }
 
     formula
     {
        z  = [0, 0];
        p  = [1, 0];
        $n = 3;
        $r = 2.0;
        $a = 0.0;
 
        while($count &lt; 20 && ssq(z) &lt; 4)
        {
           z = z ^ 2 + current;

           z1 = asech(z);
           z2 = conj(z1);

           if(
              inside(z1, r_spoly(p, $n, $r, $a)) ||
              inside(z2, r_spoly(p, $n, $r, $a))
           )
           {
              break;
           }

        }

        $r = $g = $b = 0;
 
        $value = deg(z) / 360.0 * 2.0 * $m_pi;

        $r     = 127.5 + 127.5 * sin(1.0 * $value);
        $g     = 127.5 + 127.5 * sin(1.2 * $value);
        $b     = 127.5 + 127.5 * sin(1.4 * $value);
 
        set_color($r, $g, $b);
     }
  }
  </PRE>
  <P>
  <IMG SRC="rfractal.png">
 </BODY>
</HTML>
